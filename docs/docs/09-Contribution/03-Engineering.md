In this document we list some technical details, decisions, and considerations in order to realize the software abstraction outlined in the [design documentation](/Contribution/Design).

- **Backend blindness.** The backend for now is solely responsible for storage and is unaware of what it's storing. All schemas will be defined in the frontend, which will also handle all syntactical and semantic checks. Consequently, the backend serves as a slim wrapper around the storage.
- **Storage solution.** For the early stages of implementation, the simple yet robust [SQLite3](https://www.sqlite.org/index.html) will be used. In anticipation of future modifications, we have decoupled the storage mechanisms using interfaces at `app/storage/storage.go`.
- **JSON patch.** Although [JSON Patch (RFC 6902)](https://www.rfc-editor.org/rfc/rfc6902) might seem more suitable due to its [finer granularity](https://erosb.github.io/post/json-patch-vs-merge-patch/) in array modifications, we're using [JSON Merge Patch (RFC 7396)](https://www.rfc-editor.org/rfc/rfc7396) since SQLite3 natively supports it.
- **API definition.** We utilize [OpenAPI v3.0](https://swagger.io/specification/) to define APIs between the frontend and backend. Instead of directly crafting the OpenAPI JSON, definitions are coded in `openapi/nutsh.go`, from which JSON is generated via `cmd/openapi-gen`. For defining schemas and services between backend services, [Protocol Buffers](https://protobuf.dev/) is our choice, and we employ [buf](https://buf.build/) to manage Protocol Buffers.
- **API boilerplate.** The boilerplates for backend and frontend APIs are auto-generated by [oapi-codegen](https://github.com/deepmap/oapi-codegen) and [openapi-typescript-codegen](https://github.com/ferdikoomen/openapi-typescript-codegen) respectively. For details, refer to `backend.yaml` and `frontend.yaml` in the `task` folder.
- **Strong type.** Everything is strongly typed. During development, code is statically checked using Go and TypeScript. Both at runtime and during development, JSONs are validated against schemas found in `app/frontend/src/type`.
- **Single binary executable.** Leveraging Go's [embed](https://pkg.go.dev/embed) feature, the built frontend is integrated into the backend binary, resulting in a singular, streamlined binary executable as the final product.
- **Cross compiling.** Thanks to Go's support for cross-compiling via `GOOS` and `GOARCH`, the executable can be constructed for a range of environments.
- **Docker deployment.** For Docker-based deployments, consult the `container` folder for guidance on building the runtime image. For a deployment example, see the `deploy` folder.

Additionally, the following frontend packages, which have been employed in the project, deserve mention:

- [zustand](https://github.com/pmndrs/zustand) manages frontend-only states.
- [react-query](https://github.com/TanStack/query) oversees frontend-backend states.
- [io-ts](https://github.com/gcanti/io-ts) handles JSON schema checks at runtime.
- [AntDesign](https://ant.design/) is our choice for UI.
